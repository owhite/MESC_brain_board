

#include "main.h"
#include "LED.h"
#include "pushbutton.h"
#include "tone_player.h"

static TonePlayer g_tone;
static PBHandle g_button;
PBState pb_state;

// ---------- Control tick via hardware timer ----------
IntervalTimer g_ctrlTimer;
volatile bool g_control_due = false;
volatile uint32_t g_control_now_us = 0;

static void control_isr() {
  g_control_now_us = micros();
  g_control_due = true;  // run control_step()
}

// ---------- CAN stuff using FlexCAN_T4 ----------
FlexCAN_T4<CAN_CONTROLLER, RX_SIZE_256, TX_SIZE_16> Can;

static constexpr uint16_t CAN_RX_RING_LEN = 64;
static CanFrame  g_can_rx[CAN_RX_RING_LEN];
static volatile uint16_t  g_can_w = 0, g_can_r = 0;

static inline void can_rx_push(const CAN_message_t &m) {
  uint16_t w = g_can_w;
  uint16_t n = (uint16_t)((w + 1) % CAN_RX_RING_LEN);
  if (n == g_can_r) {                      // ring full -> drop oldest
    g_can_r = (uint16_t)((g_can_r + 1) % CAN_RX_RING_LEN);
  }
  g_can_rx[w].id  = m.id;
  g_can_rx[w].len = m.len;
  for (uint8_t i = 0; i < m.len && i < 8; ++i) g_can_rx[w].buf[i] = m.buf[i];
  g_can_rx[w].t_us = micros();
  g_can_w = n;
}

// Called from Can.events() context; keep it tiny
static void can_rx_cb(const CAN_message_t &msg) {
  can_rx_push(msg);
}

// Drain & parse in the main loop (non-blocking)
static void can_drain_and_parse() {
  while (g_can_r != g_can_w) {
    CanFrame f = g_can_rx[g_can_r];       // plain copy
    g_can_r = (uint16_t)((g_can_r + 1) % CAN_RX_RING_LEN);
    (void)f; // TODO decode IDs/payloads
  }
}

// ---- LED instances ----
static LEDCtrl g_led_red;
static LEDCtrl g_led_green;

void control_step(uint32_t now_us) {

  // TODO: estimator + controller; prepare CAN command frames and send quickly.
}

bool g_pb_armed = false;

void setup() {
  Serial.begin(115200);
  while (!Serial && millis() < 1500) {}

  tone_init(&g_tone, SPEAKER_PIN);
  tone_start(&g_tone, /*freq_hz=*/2000, /*dur_ms=*/300, /*silence_ms=*/200);
  tone_update(&g_tone, micros()); 

  // LEDs
  led_init(&g_led_red,   LED1_PIN, LED_BLINK_SLOW);
  led_init(&g_led_green, LED2_PIN, LED_BLINK_FAST);
  pb_init(&g_button, PUSHBUTTON_PIN, true, 50000u);
  
  // ---- CAN init ----
  Can.begin();                           // REQUIRED first
  Can.setBaudRate(CAN_BITRATE);          // e.g., 1M for CAN 2.0
  Can.onReceive(can_rx_cb);              // catch-all callback
  Can.enableMBInterrupts();

  // ---- Control tick ISR ----
  //   set 1000 Âµs for 1 kHz
  g_ctrlTimer.begin(control_isr, CONTROL_PERIOD_US); 

}

void loop() {
  // Pump FlexCAN callbacks, then drain/parse quickly
  Can.events();
  can_drain_and_parse();

  // Run control step exactly when due
  if (g_control_due) {
    g_control_due = false;
    control_step(g_control_now_us);
  }



  // ---------- LOW PRIORITY CHORES ----------
  //   Everything here must be non-blocking
  //
  // LED stuff

  uint32_t now = micros();
  // tone_update(&g_tone, now);
  led_update(&g_led_red, now);
  led_update(&g_led_green, now);

  // Polling examples
  if (tone_is_playing(&g_tone)) {
    // currently sounding
  } else if (tone_is_silence(&g_tone)) {
    // in post-tone quiet period
  } else if (tone_is_idle(&g_tone)) {
    // all done; could schedule another tone
  }

  // pushbutton stuff
  pb_update(&g_button, now);


  while (pb_consume_change(&g_button, &pb_state)) {
    if (pb_state == PB_PRESSED) {
      g_pb_armed = true;
    }
    else {
      if (g_pb_armed) {
	LEDState cur = g_led_red.state;
	LEDState next = (cur == LED_BLINK_FAST) ? LED_BLINK_SLOW : LED_BLINK_FAST;
	if (cur != LED_BLINK_FAST && cur != LED_BLINK_SLOW) next = LED_BLINK_FAST;
	led_set_state(&g_led_red, next);
	g_pb_armed = false;
      }
    }
  }
}
